---
title: Being loved by everyone in Japan
slug: being-love-by-everyone-in-japan
date: 2020-08-31
meta_title: mendokuse
featureImage: todai.jpg
tags:
  - japanese
  - life
---

## My blooming days in Shinjuku

Đẹp lắm à hồi đó mình được yêu chiều chẳng khác gì công chúa. Dưới đây là một vài bức ảnh mình chụp khi còn ở đoá.
Chỉ có 6 tháng mà mình cảm giác mình hổng có cần ai hết, chỉ cần đi lêu hêu quanh mấy con đường là đã thấy phơi phới thanh xuân hớ hớ hớ
Gì chứ xét về nhan sắc là tui không có muốn thua ai đâu nè.

![my img](./me-in-dalat.jpg)

一見大手 Web メディアのようですが、ブログ寄りの個人運営メディアです。ファッションメディアらしく、統一感のあるおしゃれなデザインとなっています。記事自体も、きちんと取材をし、写真を撮ったうえで記事が書かれており、読み応えがあります。個人的には、スマホで見た時のファッション雑誌の表紙のようなヘッダーの表現にグッときています。

Wow, the useUndo thing itself is actually very simple now. If we had started with useReducer from the get-go, we wouldn't have even considered adding anything to our dependency array because those functions are so simple they don't need anything. All the logic lives in our reducer. That helps us avoid the issue naturally.

You may find it interesting that the switch cases in our reducer are basically exactly what the contents of our functions were before we made the change.

When one element of your state relies on the value of another element of your state in order to update: useReducer

Conclusion
So if you want some "rules" (NOT ESLINT RULES), here they are:

When it's just an independent element of state you're managing: useState
When one element of your state relies on the value of another element of your state in order to update: useReducer
Outside of these "rules," everything else is really subjective. Honestly, even the "rules" are subjective because as I demonstrated, you can do everything you want with either one.

Also, please note that this applies on a case-by-case basis. You can absolutely use useState in the same component or hook that's using useReducer. And you can have multiple useStates and multiple useReducers in a single hook or component. That's no problem. Separate state logically by domain. If it changes together, it's likely better to keep together in a reducer. If something is pretty independent from other elements of state in that hook/component, then putting it with other elements of state is just adding unnecessary complexity and noise to that reducer and you'd be better off leaving it out on its own.

So it's not just "when I have more than X number of useStates I switch to useReducer." It's more nuanced than that. But hopefully this post helps you understand those nuances and reach for the tool that has the trade-offs that work best for your situation. In general, I suggest starting with useState, and moving to useReducer when you notice elements of state need to change together.

Good luck!
